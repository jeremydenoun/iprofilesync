{
  "name": "fs-extended",
  "description": "Extends native fs module with a lot of convenient methods.",
  "version": "0.2.0",
  "homepage": "https://github.com/Darsain/fs-extended",
  "author": {
    "name": "Darsain",
    "url": "http://darsa.in"
  },
  "keywords": [
    "fs",
    "extended",
    "convenient",
    "recursive"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/Darsain/fs-extended.git"
  },
  "bugs": {
    "url": "https://github.com/Darsain/fs-extended/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  ],
  "main": "index",
  "engines": {
    "node": ">=0.10.0"
  },
  "engineStrict": true,
  "dependencies": {},
  "devDependencies": {
    "should": "*",
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha"
  },
  "readme": "# fs-extended [![Build Status](https://secure.travis-ci.org/Darsain/fs-extended.png?branch=master)](http://travis-ci.org/Darsain/fs-extended) [![NPM version](https://badge.fury.io/js/fs-extended.png)](https://npmjs.org/package/fs-extended)\n\nNode.js module that extends the native `fs` with a lot of convenient methods.\n\nIf you miss a method, and there is more than 1 person in the world that would use it,\n[create an issue](https://github.com/Darsain/fs-extended/issues)!.\n\n#### Dependencies\n\nNone.\n\n### [Changelog](https://github.com/Darsain/fs-extended/wiki/Changelog)\n\nUpholds the [Semantic Versioning Specification](http://semver.org/).\n\n## Installation\n\n```\nnpm install fs-extended\n```\n\n## Usage\n\n```js\nvar fs = require('fs-extended');\n\nfs.listFiles('foo', { recursive: 1 }, function (err, files) {\n\tconsole.log(err, files);\n});\n```\n\n## Methods\n\nAll methods from native [`fs`](http://nodejs.org/api/fs.html) module are available.\n\n### fs.createFile(path, data, [mode], [callback]);\n\nCreates a new, or overrides an existing file. Creates any missing parent directories.\n\n- **path** `String` Path to a file.\n- **data** `String|Buffer` Contents of a new file.\n- **[options]** `Object` Object with options (will be passed to `fs.writeFile`):\n\t- *encoding* `String|Null` File encoding. Defaults to `utf8`.\n\t- *mode* `Number` File mode. Defaults to `0666`. The final mode is dependent on process `umask`.\n\t- *flag* `String` File open flag. Defaults to `w`.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.createFileSync(path, data, [mode]);\n\nSynchronous `fs.createFile()`;\n\n### fs.ensureFile(path, [mode], [callback]);\n\nEnsures file exists. If it does, it'll only ensure file `mode` (when passed). If it doesn't, it'll create an empty file.\nCreates any missing parent directories.\n\n- **path** `String` Path to a file.\n- **[mode]** `Object` File mode. Defaults to `0666`. The final mode is dependent on process `umask`.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.ensureFileSync(path, [mode]);\n\nSynchronous `fs.ensureFile()`;\n\n### fs.copyFile(oldPath, newPath, [callback]);\n\nCopies a file from one location to another. Creates any missing destination directories, and works between\ndifferent partitions/filesystems. Also makes sure that file `mode` is preserved.\n\n- **oldPath** `String` Path to original file.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.copyFileSync(oldPath, newPath);\n\nSynchronous `fs.copyFile()`;\n\n### fs.moveFile(oldPath, newPath, [callback]);\n\nMoves a file from one location to another. Creates any missing destination directories, and works between\ndifferent partitions/filesystems. Also makes sure that file `mode` is preserved.\n\n- **oldPath** `String` Path to original file.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.moveFileSync(oldPath, newPath);\n\nSynchronous `fs.moveFile()`;\n\n### fs.emptyFile(file, [callback]);\n\nDeletes all contents of a file. When file doesn't exist, it is created with a default mode `0666`.\n\nA mere alias of `fs.truncate(file, 0, callback)` with an optional callback for API consistency.\n\n- **file** `String` Path to a file.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.emptyFileSync(file, [callback]);\n\nSynchronous `fs.emptyFile()`;\n\n### fs.deleteFile(file, [callback]);\n\nDeletes a file. Doesn't throw an error when file doesn't exist.\n\nA mere alias of `fs.unlink(file, callback)` with ignored `ENOENT` error and an optional callback for API consistency.\n\n- **file** `String` Path to a file.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.deleteFileSync(file, [callback]);\n\nSynchronous `fs.deleteFile()`;\n\n---\n\n### fs.createDir(dir, [mode], [callback]);\n\nCreates a directory, and any missing parent directories. If directory exists, it only ensures `mode` (when passed).\n\n- **dir** `String` Path to a new directory.\n- **[mode]** `Object` Directory mode. Defaults to `0777`. The final mode is dependent on process `umask`.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.createDirSync(dir, [mode]);\n\nSynchronous `fs.createDir()`;\n\n### fs.ensureDir(oldPath, newPath, [callback]);\n\nAlias of `fs.createDir()` for API consistency.\n\n### fs.ensureDirSync(oldPath, newPath);\n\nAlias of `fs.createDirSync()` for API consistency.\n\n### fs.copyDir(oldPath, newPath, [callback]);\n\nCopies a directory and everything in it from one location to another. Creates any missing destination directories, and\nworks between different partitions/filesystems. Also makes sure that `mode` of all items is preserved.\n\n- **oldPath** `String` Path to original directory.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.copyDirSync(oldPath, newPath);\n\nSynchronous `fs.copyDir()`;\n\n### fs.moveDir(oldPath, newPath, [callback]);\n\nMoves a directory and everything in it from one location to another. Creates any missing destination directories, and\nworks between different partitions/filesystems. Also makes sure that `mode` of all items is preserved.\n\n- **oldPath** `String` Path to original directory.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.moveDirSync(oldPath, newPath);\n\nSynchronous `fs.moveDir()`;\n\n### fs.emptyDir(dir, [callback]);\n\nDeletes everything inside a directory, but keeps the directory itself.\n\n- **dir** `String` Path to directory.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.emptyDirSync(dir);\n\nSynchronous `fs.emptyDir()`;\n\n### fs.deleteDir(dir, [callback]);\n\nDeletes a directory and everything inside it.\n\n- **dir** `String` Path to directory.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.deleteDirSync(dir);\n\nSynchronous `fs.deleteDir()`;\n\n---\n\n### fs.copy(oldPath, newPath, [callback]);\n\nCopy based on a type of the original item. Bridges to `fs.copyFile()` when `oldPath` is a file, or `fs.copyDir()` when\nit's a directory.\n\n- **oldPath** `String` Path to a file or a directory.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.copySync(oldPath, newPath);\n\nSynchronous `fs.copy()`;\n\n### fs.move(oldPath, newPath, [callback]);\n\nMove based on a type of the original item. Bridges to `fs.moveFile()` when `oldPath` is a file, or `fs.moveDir()` when\nit's a directory.\n\n- **oldPath** `String` Path to a file or a directory.\n- **newPath** `String` Destination path.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.moveSync(oldPath, newPath);\n\nSynchronous `fs.move()`;\n\n### fs.empty(target, [callback]);\n\nEmpty based on a type of the original item. Bridges to `fs.emptyFile()` when `target` is a file, or `fs.emptyDir()` when\nit's a directory.\n\n- **target** `String` Path to a file or a directory.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.emptySync(target);\n\nSynchronous `fs.empty()`;\n\n### fs.delete(target, [callback]);\n\nDelete based on a type of the original item. Bridges to `fs.deleteFile()` when `target` is a file, or `fs.deleteDir()`\nwhen it's a directory.\n\n- **target** `String` Path to a file or a directory.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\n### fs.deleteSync(target);\n\nSynchronous `fs.delete()`;\n\n---\n\n### fs.listAll(dir, [options], [callback]);\n\nList all directories and files inside a directory.\n\n- **dir** `String` Path to a directory.\n- **[options]** `Object` Object with options:\n\t- *recursive* `Boolean` List items recursively, expanding all child directories. Defaults to `false`.\n\t- *prependDir* `Boolean` Prepend `dir` path before every item in final array. Defaults to `false`.\n\t- *filter* `Function` Function to filter items. Should return `true` or `false`. Receives arguments:\n\t\t- *itemPath* `String` Full path to an item.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a file.\n\t- *map* `Function` Function to map final list items. Mapping is applied after *filter*. Receives arguments:\n\t\t- *itemPath* `String` Full path to an item.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a file.\n\t- *sort* `Boolean | Function` Pass `true` to sort files\n\t\t[lexicographically](http://en.wikipedia.org/wiki/Lexicographical_order), or a compare function you'd normally\n\t\tpass to an `Array.sort()`. Sorting is applied after *filter* & *map*. Function accepts two file paths (or\n\t\twhatever *map* returned) for comparison.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\t- *list* `Array` List of items inside a directory.\n\nThe purpose of built-in filter/map functions is to recycle `fs.Stats` objects when needed, as loading this objects is\nthe biggest bottleneck when listing files recursively.\n\nThe `fs.Stats` for each file is loaded only when recursive listing is requested, or filter/map functions accept it as an\nargument.\n\nOn the other hand, if your filter/map needs something that `fs.Stat` provides, just use it. There is no way how to make\ndata retrieval by `fs.stat()` faster (I'd like to be corrected on this if I'm wrong! :)).\n\n##### Examples\n\nFilter out directories, effectively turning `fs.listAll()` into `fs.listFiles()`:\n\n```js\nfunction filter(itemPath, stat) {\n\treturn stat.isFile();\n}\n\nfs.listAll(dir, { filter: filter }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // array of all files inside a directory\n});\n```\n\nMap files into a more descriptive array of objects:\n\n```js\nfunction map(itemPath, stat) {\n\treturn {\n\t\tpath: itemPath,\n\t\tname: path.basename(itemPath),\n\t\text: path.extname(itemPath),\n\t\tsize: stat.size,\n\t};\n}\n\nfs.listAll(dir, { map: map }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // array of file object descriptors returned by map()\n\t// Example\n\tfiles[0].path; // 1st file's path\n\tfiles[0].ext;  // 1st file's extension\n});\n```\n\nSort files by their name [lexicographically](http://en.wikipedia.org/wiki/Lexicographical_order):\n\n```js\nfs.listAll(dir, { sort: true }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // sorted array of files\n});\n```\n\nSort files by their extension with a compare function:\n\n```js\nfunction compare(a, b) {\n\treturn path.extname(a) < path.extname(b) ? -1 : 1;\n}\n\nfs.listAll(dir, { sort: compare }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // sorted array of files\n});\n```\n\n### fs.listAllSync(dir, [options]);\n\nSynchronous `fs.listAll()`;\n\n### fs.listFiles(dir, [options], callback);\n\nList all files inside a directory.\n\n- **dir** `String` Path to a directory.\n- **[options]** `Object` Object with options:\n\t- *recursive* `Boolean` List files recursively, expanding all child directories. Defaults to `false`.\n\t- *prependDir* `Boolean` Prepend `dir` path before every item in final array. Defaults to `false`.\n\t- *filter* `Function` Function to filter items. Should return `true` or `false`. Receives arguments:\n\t\t- *filePath* `String` Full path to a file.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a file.\n\t- *map* `Function` Function to map final list items. Mapping is applied after *filter*. Receives arguments:\n\t\t- *filePath* `String` Full path to a file.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a file.\n\t- *sort* `Boolean | Function` Pass `true` to sort files\n\t\t[lexicographically](http://en.wikipedia.org/wiki/Lexicographical_order), or a compare function you'd normally\n\t\tpass to an `Array.sort()`. Sorting is applied after *filter* & *map*. Function accepts two file paths (or\n\t\twhatever *map* returned) for comparison.\n- **callback** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\t- *files* `Array` List of files inside a directory.\n\n##### Examples\n\nList all files in a directory recursively, and sort them by size:\n\n```js\nfunction map(filePath, stat) {\n\treturn {\n\t\tpath: filePath,\n\t\tsize: stat.size,\n\t};\n}\n\nfunction compare(a, b) {\n\treturn a.size < b.size ? -1 : 1;\n}\n\nfs.listAll(dir, { map: map, sort: compare }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // array of file object descriptors returned by map()\n\t// Example\n\tfiles[0].path; // 1st file's path\n\tfiles[0].size; // 1st file's size\n});\n```\n\n### fs.listFilesSync(dir, [options]);\n\nSynchronous `fs.listFiles()`;\n\n### fs.listDirs(dir, [options], callback);\n\nList all directories inside a directory.\n\n- **dir** `String` Path to a directory.\n- **[options]** `Object` Object with options:\n\t- *recursive* `Boolean` List directories recursively, expanding all child directories. Defaults to `false`.\n\t- *prependDir* `Boolean` Prepend `dir` path before every directory in final array. Defaults to `false`.\n\t- *filter* `Function` Function to filter items. Function should return `true` or `false`. Receives arguments:\n\t\t- *dirPath* `String` Full path to a directory.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a directory.\n\t- *map* `Function` Function to map final list items. Mapping is applied after *filter*. Receives arguments:\n\t\t- *dirPath* `String` Full path to a directory.\n\t\t- *stat* [`fs.Stats`](http://nodejs.org/api/fs.html#fs_class_fs_stats) Object with data about a directory.\n\t- *sort* `Boolean | Function` Pass `true` to sort directories\n\t\t[lexicographically](http://en.wikipedia.org/wiki/Lexicographical_order), or a compare function you'd normally\n\t\tpass to an `Array.sort()`. Sorting is applied after *filter* & *map*. Function accepts two directory paths (or\n\t\twhatever *map* returned) for comparison.\n- **callback** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\t- *dirs* `Array` List of directories inside a directory.\n\n##### Examples\n\nList all directories in a directory recursively, and sort them by modification time:\n\n```js\nfunction map(dirPath, stat) {\n\treturn {\n\t\tpath: dirPath,\n\t\tmtime: stat.mtime,\n\t};\n}\n\nfunction compare(a, b) {\n\treturn a.mtime < b.mtime ? -1 : 1;\n}\n\nfs.listAll(dir, { map: map, sort: compare }, function (err, files) {\n\tconsole.log(err);   // possible exception\n\tconsole.log(files); // array of file object descriptors returned by map()\n\t// Example\n\tfiles[0].path;  // 1st directory's path\n\tfiles[0].mtime; // 1st directory's mtime\n});\n```\n\n### fs.listDirsSync(dir, [options]);\n\nSynchronous `fs.listDirs()`;\n\n---\n\n### fs.uniquePath(path, [no], callback);\n\nGenerates a unique path that won't override any other file.\n\nIf path doesn't exist, it is simply returned. Otherwise it will insert \"-N\" suffix between the file\nname and its extension (if there is any) until it finds a path that doesn't exist yet.\n\n**Be aware of [Race condition](http://en.wikipedia.org/wiki/Race_condition)!**\n\n- **path** `String` Path to be uniquefied.\n- **[no]** `Integer` Starting number index. Defaults to `2`.\n- **callback** `Function` Receives arguments:\n\t- *uniquePath* `String` Unique version of the original path.\n\n##### Example\n\nWith a directory structure:\n\n```\ndir\n├─ foo\n├─ bar.txt\n├─ bar-2.txt\n├─ bar-3.txt\n└─ baz.tar.gz\n```\n\nThese are the outputs:\n\n```js\nfs.uniquePath('dir/unique', function (uniquePath) {\n\tuniquePath; // => dir/unique\n});\n```\n\n```js\nfs.uniquePath('dir/foo', function (uniquePath) {\n\tuniquePath; // => dir/foo-2\n});\n```\n\n```js\nfs.uniquePath('dir/bar.txt', function (uniquePath) {\n\tuniquePath; // => dir/bar-4.txt\n});\n```\n\n```js\nfs.uniquePath('dir/baz.tar.gz', function (uniquePath) {\n\tuniquePath; // => dir/baz-2.tar.gz\n});\n```\n\n### fs.uniquePathSync(path, [no]);\n\nSynchronous `fs.uniquePath()`;\n\n### fs.writeJSON(file, data, [indentation], [callback]);\n\nFormat data in JSON and write into a file. Creates destination directory if it doesn't exist yet.\n\n- **file** `String` Path to a destination file.\n- **data** `Mixed` Data to be formated in JSON.\n- **[indentation]** `Mixed` Number of spaces, or a direct representation of a single indentation level, like '\\t'.\n\tDefaults to no indentation.\n- **[callback]** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\nAlias: `fs.writeJson()`\n\n### fs.writeJSONSync(file, data, [indentation]);\n\nSynchronous `fs.writeJSON()`;\n\nAlias: `fs.writeJsonSync()`\n\n### fs.readJSON(file, callback);\n\nEncode data in JSON format and write into a file. Creates destination directory if it doesn't exist yet.\n\n- **file** `String` Path to a JSON file.\n- **callback** `Function` Receives arguments:\n\t- *err* `Mixed` Error object on error, `null` otherwise.\n\t- *data* `Mixed` Data from JSON file.\n\nAlias: `fs.readJson()`\n\n### fs.readJSONSync(file);\n\nSynchronous `fs.readJSON()`;\n\nAlias: `fs.readJsonSync()`",
  "readmeFilename": "README.md",
  "_id": "fs-extended@0.2.0",
  "dist": {
    "shasum": "9523d413a014d1a6e35b2a64baa5e66d17f0c6fe",
    "tarball": "http://registry.npmjs.org/fs-extended/-/fs-extended-0.2.0.tgz"
  },
  "_from": "fs-extended@*",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "darsain",
    "email": "darsain@gmail.com"
  },
  "maintainers": [
    {
      "name": "darsain",
      "email": "darsain@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "9523d413a014d1a6e35b2a64baa5e66d17f0c6fe",
  "_resolved": "https://registry.npmjs.org/fs-extended/-/fs-extended-0.2.0.tgz"
}
